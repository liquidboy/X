// WARNING: Please don't edit this file. It was generated by C++/WinRT v1.0.190111.3

#pragma once

WINRT_EXPORT namespace winrt::Windows::Storage::Streams {

struct IBuffer;

}

WINRT_EXPORT namespace winrt::Windows::UI::Composition {

struct Compositor;

}

WINRT_EXPORT namespace winrt::Windows::UI::Composition::Scenes {

struct SceneNode;

}

WINRT_EXPORT namespace winrt::SceneLoaderComponent {

struct ISceneLoader;
struct SceneLoader;

}

namespace winrt::impl {

template <> struct category<SceneLoaderComponent::ISceneLoader>{ using type = interface_category; };
template <> struct category<SceneLoaderComponent::SceneLoader>{ using type = class_category; };
template <> struct name<SceneLoaderComponent::ISceneLoader>{ static constexpr auto & value{ L"SceneLoaderComponent.ISceneLoader" }; };
template <> struct name<SceneLoaderComponent::SceneLoader>{ static constexpr auto & value{ L"SceneLoaderComponent.SceneLoader" }; };
template <> struct guid_storage<SceneLoaderComponent::ISceneLoader>{ static constexpr guid value{ 0xF2E551AF,0x5469,0x538E,{ 0xBF,0x2D,0x1D,0x26,0x99,0x10,0xA7,0x2A } }; };
template <> struct default_interface<SceneLoaderComponent::SceneLoader>{ using type = SceneLoaderComponent::ISceneLoader; };

template <> struct abi<SceneLoaderComponent::ISceneLoader>{ struct type : IInspectable
{
    virtual int32_t WINRT_CALL Load(void* buffer, void* compositor, void** result) noexcept = 0;
};};

template <typename D>
struct consume_SceneLoaderComponent_ISceneLoader
{
    Windows::UI::Composition::Scenes::SceneNode Load(Windows::Storage::Streams::IBuffer const& buffer, Windows::UI::Composition::Compositor const& compositor) const;
};
template <> struct consume<SceneLoaderComponent::ISceneLoader> { template <typename D> using type = consume_SceneLoaderComponent_ISceneLoader<D>; };

}
